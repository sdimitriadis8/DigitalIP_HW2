%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%
%&%                                                   %&%
%&%        Εργασία Δημητριάδη Σωκράτη Α.Μ.:359        %&%
%&%                                                   %&%
%&%    Τ.08 - ΘΕΜΑΤΑ ΨΗΦΙΑΚΗΣ ΕΠΕΞΕΡΓΑΣΙΑΣ ΕΙΚΟΝΑΣ    %&%
%&%          ΣΥΜΠΙΕΣΗ ΚΑΙ ΥΠΕΡΑΝΑΛΥΣΗ ΒΙΝΤΕΟ          %&%
%&%                                                   %&%
%&%           2Η ΠΡΟΓΡΑΜΜΑΤΙΣΤΙΚΗ ΑΣΚΗΣΗ              %&%
%&%                                                   %&%
%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%&%
%--------------------------------------------------------
% Θα χρησιμοποιήσουμε 4 εικόνες σε LR(Low Resolution-χαμηλής ανάλυσης),
% όπως περιγράφηκε στο άρθρο των Park, Park και Kang, στην ντετερμινιστική
% προσέγγιση της "κανονικοποιημένης" SR(Super Resolution) ανακατασκευής.
% Οι εικόνες θα φτιαχτούν στη συνέχεια, κάνοντας χρήση της εικόνας
% 'cameraman'. 
%
% Σημείωση: Για λόγους συνέπειας με τη θεωρία, έχουν μετονομαστεί
% οι ακόλουθες μεταβλητές στις αντίστοιχες:  
%               .imlowres-->y (οι εικόνες χαμηλής ανάλυσης)
%               .imshift-->M (ο πίνακας κίνησης)
%               .imblur-->B (ο πίνακας θόλωσης)
%               .x0-->xp (η αρχική εκτίμηση της μεθόδου)
%
f=imread('cameraman.tif'); % Φόρτωση της εικόνας από τη μνήμη στην f
f=double(f); 

sigma=0.4; % Επιλέγουμε ως τυπική απόκλιση για το Γκαουσιανό
           % μοντέλο την τιμή σ=0.4
sigma2=2;  % Επιλέγουμε έναν παράγοντα κλιμάκωσης μεγέθους 2
p=4;   % (Η επαναληπτική μέθοδος για 4 εικόνες)

M(:,:,1)=f; % Ως 1ο πίνακα κίνησης επιλέγουμε την ίδια την f (cameraman), 
            % δηλαδή χωρίς καμία μετατόπιση.
M(:,:,2)=zeros(256,256); % Αρχικοποιήσεις των υπόλοιπων 
M(:,:,3)=zeros(256,256); % τριών πινάκων κίνησης σε
M(:,:,4)=zeros(256,256); % πίνακες με μηδενικά

% Φτιάχνουμε τη δεύτερη εικόνα με τον πίνακα κίνησης,
% παίρνοντας την εικόνα της f μετατοπισμένη κάτα μία στήλη δεξιά.
% Αυτό γίνεται ως εξής:
for i=1:256
    for j=1:255
        M(i,j,2)=f(i,j+1);
    end
end

% Για την τρίτη εικόνα, κάνουμε το ίδιο κατά αντιστοιχία
% και για τις γραμμές της f (κατά μία γραμμή κάτω), ως εξής:
for i=1:255
    for j=1:256
        M(i,j,3)=f(i+1,j);
    end
end

% Τέλος, η τέταρτη εικόνα προκύπτει με ταυτόχρονη
% μετατόπιση κάτα μία στήλη και μία γραμμή. 
% Αυτό γίνεται ως εξής:
for i=1:255
    for j=1:255
        M(i,j,4)=f(i+1,j+1);
    end
end

% Ορίζουμε ένα Γκαουσιανό χαμηλοπερατό φίλτρο μεγέθους  
% 15x15 με τυπική απόκλιση σ=0.4...
h=fspecial('gaussian',[15 15], sigma);
% ... και με αυτό, κατασκευάζουμε έναν πίνακα 
% που εκφράζει τη θόλωση εφαρμόζοντας διδιάστατη
% συνέλιξη με τις τέσσερις εικόνες, διατηρώντας το
% αρχικό μέγεθος της εικόνας (256x256).
B=zeros(256,256,p);
for k=1:p
    B(:,:,k)=conv2(M(:,:,k),h,'same');
end

% Επιπλέον κάνουμε υποδειγματοληψία μέσω της 
% συνάρτησης 'subsample', εφαρμοσμένη σε αυτές
% τις εικόνες που προέκυψαν από τη θόλωση (προηγουμένως)
% με παράγοντα επιλογής στοιχείων l=2. Δηλαδή επιλέγουμε
% τα στοιχεία από τις "θολωμένες" εικόνες ένα παρά ένα.
% Τέλος, προσθέτουμε κι έναν πίνακα-θόρυβο με τυχαίους 
% αριθμούς, διαστάσεων 128x128 και μεγεθυσμένο κατά 2
y=zeros(128,128,p);
for k=1:p
    y(:,:,k)=subsample(B(:,:,k),2)+sigma2*randn(128);
end

% Τότε, επιλέγουμε ως αρχική εκτίμηση της επαναληπτικής 
% μεθόδου την πρώτη εικόνα από τις τέσσερις, που προέκυψαν 
% από την παραπάνω διαδικασία, διπλασιάζοντας το μέγεθός της
xp=imresize(y(:,:,1),2); % Αρχικοποίηση της x-previous

% ’ποθήκευση της xp στη x0 για τις τελικές συγκρίσεις 
x0=xp; 

% Ορισμός των παραγόντων α και β της μεθόδου
b=0.01;
a=0.01;

% Ορισμός της ανοχής του μέτρου της διαφοράς
% μεταξύ δύο διαδοχικών εκτιμήσεων προς το μέτρο
% της προηγούμενης εκτίμησης. Ουσιαστικά είναι
% ο παράγοντας ακρίβειας που απαιτούμε να έχει
% η τελική εικόνα. Όσο μικρότερος, τόσο καλύτερη
% η ποιότητα της εικόνας.
T=10^(-8);

e=1; % Αρχικοποίηση της ποσότητας ελέγχου στο 0, για
     % για να ισχύει η συνθήκη πριν την έναρξη της
     % επαναληπτικής μεθόδου

% Υπολογισμός δεύτερου όρου της μεθόδου
% για έλεγχο της συνθήκης τερματισμού

% Ορίζουμε το εξής Λαπλασιανό (υψηλοπερατό) φίλτρο
c=[0 -1/4 0; -1/4 1 -1/4; 0 -1/4 0]; 

              % Παίρνουμε διδιάστατη συνέλιξη με τον εαυτό του
d=conv2(c,c); % κι έχουμε έναν 5x5 πίνακα-φίλτρο, που θα εφαρμόζουμε
              % σε κάθε βήμα της μεθόδου, στην προηγούμενη εκτίμηση

n=0;
xn=xp; % Αρχικοποίηση της x-new στην x-previous
       % (απλώς για αποφυγή σφαλμάτων του Matlab)

% Έναρξη της επαναληπτικής μεθόδου
while(e>T)
    factor1=zeros(256);
    xp=xn;
    
    % Αφού οι εικόνες χαμηλής ανάλυσης, y, που θα χρειαστούμε
    % έχουν υπολογισθεί, αρκεί να υπολογίζουμε τις Wk της
    % προηγούμενης προσέγγισης και να τις αφαιρούμε από τις y.
    % (σημειώνεται ότι Wk=Dk*Bk*Mk)
    % Για να το πετύχουμε, κάνουμε τα εξής βήματα:
    % Εκ νέου υπολογισμός των Mk:
    M(:,:,1)=xp; % Η προηγούμενη εκτίμηση, χωρίς μετατόπιση
    
    % Η προηγούμενη εκτίμηση, με μετατόπιση
    % προς τα δεξιά
    for i=1:256
        for j=1:255
            M(i,j,2)=xp(i,j+1);
        end
    end

    % Η προηγούμενη εκτίμηση, με μετατόπιση
    % προς τα κάτω
    for i=1:255
        for j=1:256
            M(i,j,3)=xp(i+1,j);
        end
    end

    % Και τέλος, η προηγούμενη εκτίμηση, με μετατόπιση
    % προς τα δεξιά και προς τα κάτω, δηλαδή διαγώνια
    for i=1:255
        for j=1:255
            M(i,j,4)=xp(i+1,j+1);
        end
    end
    % Κατασκευάσαμε έτσι τις Mk(xp), δηλαδή τις εικόνες
    % κίνησης της προηγούμενης εκτίμησης
    
    for k=1:p
        % Κατασκευή του πρώτου όρου της παρένθεσης
        % στον τύπο της μεθόδου:
        B(:,:,k)=conv2(M(:,:,k),h,'same'); % Θόλωση των Mk
        Wx(:,:,k)=subsample(B(:,:,k),2); % Υποδειγματοληψία των BkMk
        differ(:,:,k)=y(:,:,k)-Wx(:,:,k); % Οι διαφορές yk-Wk(x)
        
        % Συνέλιξη του αναστρόφου του Wk με τις διαφορές,
        % δηλαδή διαδοχικές διδιάστατες συνελίξεις με τους αναστρόφους
        % των D, Bk και Mk (ο ανάστροφος, WT, του Wk=DBkMk είναι ο 
        % WT=MT*BT*DT). ’ρα η σειρά των διδιάστατων συνελίξεων είναι η 
        % ίδια με τη σειρά που αναφέρθηκαν παραπάνω. Ώστε έχουμε:
        DT(:,:,k)=upsample(differ(:,:,k),2);
        BT(:,:,k)=conv2(DT(:,:,k),h,'same');
        
        % (Μένει να αντιστρέψουμε την κίνηση, διαδικασία η
        % οποία θα πραγματοποιηθεί εκτός αυτής της επανάληψης)
    end
    
    % Τα ανάστροφα Μκ, περιγράφουν την αντίστροφη κίνηση,
    % δηλαδή έχουμε:
    MT(:,:,1)=BT(:,:,1); % Το Βk ανάστροφο, χωρίς μετατόπιση

    % Η μετατόπιση του Βk-ανάστροφο προς τα αριστερά
    for i=1:256
        for j=2:256
            MT(i,j,2)=BT(i,j-1,2);
        end
    end

    % Η μετατόπιση του Βk-ανάστροφο προς τα πάνω
    for i=2:256
        for j=1:256
            MT(i,j,3)=BT(i-1,j,3);
        end
    end

    % Και κατά αντιστοιχία, μετατόπιση του Βk-ανάστροφο 
    % προς τα πάνω και αριστερά, δηλαδή διαγώνια προς τα πίσω
    for i=2:256
        for j=2:256
            MT(i,j,4)=BT(i-1,j-1,4);
        end
    end

    % ’θροιση των p εικόνων
    for k=1:p
        factor1=factor1+MT(:,:,k);
    end
    
    % Κατασκευή του δεύτερου όρου της παρένθεσης
    % στον τύπο της μεθόδου:
    CCx=conv2(xp,d,'same');
    factor2=a*CCx;
    
    % Κατασκευή του όρου της διαφοράς
    factor=b*(factor1-factor2);
    
    % Υπολογισμός της νέας εκτίμησης της μεθόδου x(n+1)
    xn=xp+factor;
    
    % Υπολογισμός της ποσότητας ελέγχου σύγκλισης της μεθόδου
    e=((norm(xn-xp))^2)/((norm(xp)^2));
    
    n=n+1; % Καταμέτρηση επαναλήψεων για λόγους αποσφαλμάτωσης
end

% Έλεγχος για αρνητικές ή άνω-του-255 τιμές
% και αντικατάσταση αυτών με 0 ή 255, αντίστοιχα.
for i=1:256
    for j=1:256
        if (xn(i,j)<0)
            xn(i,j)=0;
        end
        if (xn(i,j)>255)
            xn(i,j)=255;
        end
    end
end

% Μετατροπή των απαραίτητων εικόνων, σε μορφή uint8
xnu=uint8(xn);
x0u=uint8(x0);
fu=uint8(f);

% Εκτύπωση της τελικής εικόνας, μετά την επεξεργασία...
figure
imshow(xnu);

% ... καθώς και το P.S.N.R. αυτής και της αρχικής (f) 
fxnpsnr=psnr(xnu,fu)

% Εκτύπωση της εκτιμώμενης εικόνας του x0, 
% που προέκυψε από το imresize...
figure
imshow(x0u);

% ... και το αντίστοιχο P.S.N.R. αυτής και της αρχικής (f)
fx0psnr=psnr(x0u,fu)
